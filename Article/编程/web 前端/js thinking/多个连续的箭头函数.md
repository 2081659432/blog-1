# 多个连续的箭头函数和柯里化的关系

## 高阶函数
一般而言，我们要理解常见的高阶函数还是很容易的。比如：

```js
function add(a) {
    return function(b) {
        return a + b
    }
}

var add3 = add(3)
add3(4) === 3 + 4 //true
```

## 多个连续的箭头函数
我们常用的 sort、map、reduce 这些都是高阶函数，but 当一堆箭头函数在你面前的时候，你会不会有一丝犹豫，我在此之前就是一脸懵逼。。。比如看到下面的redux-thunk 的源码的时候。。。a => b => c => {xxx} 。。。。


![](http://7xkpdt.com1.z0.glb.clouddn.com/7040fddb0b0690e69b10a2bedfde5254.png)

## 柯里化
![](http://7xkpdt.com1.z0.glb.clouddn.com/215e06423ca5fbf028d45e59f468dcaa.png)

好，现在懂没，我来简单说一下，其实非常简单。

关键就是柯里化，其实可以理解成，将变量存在函数里面了，然后本来需要俩参数的函数可以变成只要一个参数，比如

```js
let add = x => y => x + y
let add2 = add(2)
```

本来完成 add 这个操作，应该是
```js
let add = (x, y) => x + y
```
需要俩参数，现在 add2 只需要一个参数，这在函数式编程中广泛应用。

详细解释一下，就是这里的 add2 就是有了 x 这个闭包变量的
```js
y => x + y
```
并且此时 x = 2，所以此时调用

```js
add2(3) === 2 + 3
```

## 回归正题

```js
a => b => c => {xxx}
```

和柯里化有什么关系呢，请注意

```js
let add = x => y => x + y

```

so 多个箭头函数连在一起 就是在柯里化。

那么怎么理解呢，这已经非常简单了。

```js
let test = a => b => c => {xxx}
```
`test(a)(b)(c)`  返回 xxx 的返回值，并且在 xxx 中可以调用 a,b,c


那么下面的代码(createThunkMiddleware)是不是瞬间就看懂了

![](http://7xkpdt.com1.z0.glb.clouddn.com/7040fddb0b0690e69b10a2bedfde5254.png)
