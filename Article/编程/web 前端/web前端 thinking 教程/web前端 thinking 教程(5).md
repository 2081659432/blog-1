# web前端 thinking 教程(5)

## 教学提纲
- 作业问题讲解
    - react 方面
    - model 方面
    - 同学们的问题
- 服务器端基础知识
    - 使用 node 运行服务器
    - 传统前端开发
    - 后端提供 api 的开发方式
        - restful api
        - ajax 基础知识
        - 示例
    - http 基础知识
- 作业
    - 完成上次的程序
    - 阅读架构模式讲解
    - 下次讲
        - MV*
        - react
        - redux 介绍

## 作业问题讲解
发 issue，老地方

## 服务器端基础知识
### 使用 node 运行服务器介绍
- 数据库
    - 建立表结构
    - 增删改查
- 路由（详情看作业的 MV* 架构部分）
    - url 匹配规则
    - 业务逻辑处理
- 后端渲染（后端模板，根据 url，使用（数据库里的）数据渲染出 html，给浏览器）
- 其他（还有不少难点，比如负载均衡来达到高并发、高性能服务器，等等，不过最基础的就我上面所列举的，也没什么难的，后端的难点在于各种各样的提高性能、大型网站的架构）

### 传统前端开发
纯后端渲染，每次 http 请求返回一个新的 html，css 为主，无 ajax 或少量 ajax，js 主要是动画和脚本，并不负责数据的渲染，也就是后端模板生成返回给浏览器的 html，所以是后端开发占主力。

> 前端渲染、后端渲染

但是像 node 就给了 js 后端渲染页面的能力，而且就算后端不用 node 前端也是能具有渲染能力的，使用 vue，angular，react 就可以轻松做到（手写就会很不轻松。。）。

### 现代前端开发
- ajax
    - 后端提供 api 的开发方式
    - 甚至是后端 直接提供 restful api（详情见作业的阅读）
- 前端渲染（vue，angular，react）和后端渲染配合进行，以达到性能最优
- spa（单页应用，比如我的博客）
- 同构（react 服务器端渲染，在 spa 中首屏后端渲染，其他页面由前端渲染，共用一套代码）

### http 基础知识
统一资源标识符:URI;统一资源定位符:URL

后者是前者的子集，比如 链接 既是 URI 也是 URL，每种书籍一般会有一个独一无二的书刊号，这个书刊号就是 URI，不是 URL

URL 的五部分(以 'https://www.google.com.tw/webhp?sourceid...' 为例):
1. 传送协议(https://)。
2. 服务器。（通常为域名，有时为IP地址）（www.google.com.tw）
3. 端口号。（以数字方式表示，若为HTTP的预设值“:80”可省略）（已省略）
4. 资源路径。（以“/”字元区别路径中的每一个目录名称）（webhp）
5. 查询。（GET模式的表单参数，以“?”字元为起点，每个参数以“&”隔开，再以“=”分开参数名称与资料，通常以UTF8的URL编码，避开字元冲突的问题）（?sourceid...）

阅读资料：
http://blog.qiji.tech/archives/1506

其中状态码可以略读，但是要抓住重点：
1. 1XX信息性状态码，表示消息已经收到，请继续
2. 2XX成功状态码
3. 3XX重定向状态码，304重定向
4. 4XX客户端错误(Client Error)
5. 5XX服务器错误代码

最关键的不是记忆，而是，用 chrome dev tool，的 network 面板里面，观察 http 请求到底长什么样。

![](http://7xkpdt.com1.z0.glb.clouddn.com/05c86f20c6fdc3eae7ac4f9be56ecef2.png)

![](http://7xkpdt.com1.z0.glb.clouddn.com/22a7eca2ed782fec99731d24849d1ca1.png)

![](http://7xkpdt.com1.z0.glb.clouddn.com/4d842149a4b0ee2a749e0236287650e3.png)



## 作业
1. 完成上次作业
2. 阅读

## 阅读
#### restful api
阅读： 理解RESTful架构 http://www.ruanyifeng.com/blog/2011/09/restful.html

核心摘要：
> 五、状态转化（State Transfer）
访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。
互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。
客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。

> 六、综述
综合上面的解释，我们总结一下什么是RESTful架构：
1. 每一个URI代表一种资源；
2. 客户端和服务器之间，传递这种资源的某种表现层；
3. 客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。

### 架构模式讲解
> 你在写上百行的程序或许只用一个文件，代码还是可以写的很清晰; 几百行的程序或许使用几个文件，项目可以写的很不错;但当你写上千行甚至上万行的软件的时候，没有架构模式，你的代码会变得一团糟。

#### 介绍
图形界面应用程序复杂性管理问题，造就了典型的 MVC 模式。

基础知识:
- M 是 model 的缩写，可以理解成数据的抽象，V 是 view 的缩写，可以理解为视图的抽象，C 是 controller 的缩写，可以理解为控制、响应交互的抽象。
- 一个通俗易懂的例子就是，M 是 人的重量、身高、年龄等数据，V 是人的样子，C 是人的灵魂，C 要面对外界的事作出反应。

#### 阅读资料
界面之下：还原真实的MV*模式: http://www.html-js.com/article/3198

（这次的阅读有一定难度，请结合后面的内容解读来阅读）

如果对 MVC 了解吃力 MVP 方面的知识可以略读。重点在 MVC 和 MVVM，并且在这里，架构模式首先是用在整个 web 应用（前端+后端,前端只是一个 view，css 是主力，然后 js 只是动画、小脚本。。。），到了 ajax 应用崛起之后，前端方面开始有独立的整个架构模式，这就是分形架构模式（远看 web 应用整个是一个 MVC。近看，前端有一个 MV*，后端又有一个 MVC），react 里，js 占比重60%+，甚至可以服务器端也全是 js，安卓 ios 用 react native，全端都是 js。。。。

核心内容解读：
- MV* 都是为了解决图形界面应用程序复杂性管理问题而产生的应用架构模式
    - 复杂性管理问题: 有维护数据、响应事件、维护视图、数据和视图的绑定(数据更改后，视图应该也要修改)
    - 应用架构模式：是一种分离职责的模式，使用不同的模块来分别维护应用的不同部分，让每个模块各司其职。
- 职责详解（以 MVC 为例）
    - Model 提供数据操作的接口，执行相应的业务逻辑，比如数据的增删改查的接口，都应该由 Model 维护，复杂的业务应该是其他模块去调用这些接口来实现，而不是写在 Model 里。Model 仅仅提供纯粹的数据操作接口，在 MVC 模式中，Model 还会实现观察者模式（和 js 的 addEventListener 原理一样一样的，dom 里是对事件的监听，这里是 view 对 model 的数据的改变的监听，然后当数据改变后，view 根据自己的需求去显示最新的样子）。
    - View 实现整个页面的样子，分两部分，第一部分是 构造 View 时，通过 Model 层的数据来构造，比如文章数据在 model 里面，view 通过查，得到数据再展示出来。第二部分是，当 model 被修改后，view 应该更新自己，这个的实现，在 MVC 中，View 会根据自己的需求（比如，如果 view 是评论 view，那么它就会去订阅 评论数据的更改 的事件）去订阅Model变更的消息
    - Controller 操作 Model，当响应事件（用户点赞、评论等）的时候，C 会去调用 Model 提供的接口，来执行业务逻辑对数据进行处理。但不会直接操作View，可以说它是对View无知的。
- MVC 的优缺点
    - 优点：把业务逻辑和展示逻辑分离，模块化程度高。当 model 更改后，观察者模式可以做到多视图同时更新（这里的体现是，页面内有多处视图，比如）。
    - 缺点:
        - Controller 测试困难。因为视图同步操作是由 View 自己执行，而 View 只能在有UI的环境下运行。在没有UI环境下对 Controller 进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。
        - View 无法组件化。View 是强依赖特定的 Model 的
- web 开发中的 MVC
    - 实际上 C 层是路由层（路由规则 + 响应处理），http 请求发过来后，后端根据路由规则交给 C 去进行响应处理。
- MVVM(= M + V + VM)
    - M 层和 V 层，通过 VM 层双向绑定，达到了双向数据绑定(当 model 中的数据更改后，view 会自动更新)。
    - 缺点:
        - 对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高
        - 数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的(react 大法好？不过 react 代码量确实是会比 view 多不少)

### 下次开始大作业
- (6, 7, 8, 9)自由发挥，1000行代码以上的项目
    - 必用：es6、react、webpack。
    - 选用：react router、react native
