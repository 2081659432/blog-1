# 前端面试题笔记(2)
## 来源
[http://ourjs.com/detail/52c4145d7986593603000009](http://ourjs.com/detail/52c4145d7986593603000009)

[https://github.com/AutumnsWind/Front-end-questions-to-the-interview-stage](https://github.com/AutumnsWind/Front-end-questions-to-the-interview-stage)

[https://github.com/hawx1993/Front-end-Interview-questions](https://github.com/hawx1993/Front-end-Interview-questions)

## 理论
### null和undefined的区别？
null是一个表示"无"的对象；undefined是一个表示"无"的原始值。

当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。

null典型用法是：
1. 作为函数的参数，表示该函数的参数不是对象。
2. 作为对象原型链的终点。

undefined 典型用法是：
1. 变量或对象属性被声明了，但没有赋值时，就等于undefined。
2. 调用函数时，未传入参数，函数内部该参数等于undefined。
3. 函数没有返回值时，默认返回undefined。

### new操作符具体干了什么呢?

```js
// 1. 创建一个空对象，同时还继承了该函数的原型。
var obj = {};
obj .__ proto__ = Base.prototype;

// 2. call调用函数，以空对象为 this，这样以来属性和方法被加入到 this 中。
// 3. 也就是加给了之前 call 传入的空对象 。
Base.call (obj);
```

### javascript 创建对象
我喜欢，组合构造函数（赋值属性）和原型模式（创建方法）来创建对象。

### js 继承
我喜欢，寄生组合式继承


### 如何理解闭包
#### 闭包的形成
js 是函数作用域的，其中内层函数可以访问外层函数里的变量，这时便形成了闭包。

```js
// 其中 myFunc 就是 闭包
function makeFunc() {
    var name = "Mozilla";
    function displayName() {
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc();
```

#### MDN中说道
> 1. 闭包是指函数有自由独立的变量。也就是，定义在闭包中的函数可以“记忆”它创建时候的环境（即其作用域存在的所有变量）。
> 2. 闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境（两者合起来可以视作为整个外层函数 makeFunc 的返回值 myFunc）


#### 用处
1. 设计模块中的私有属性和方法（闭包中的自由变量 如上面代码的 `name`，它无法被直接访问）
2. 让这些变量的值始终保持在内存中(可以被延迟调用，比如事件 handler，ajax 异步调用的回调函数等)。

### 如何解决跨域问题
#### JSONP

#### CORS
服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问

### Ajax
#### 完整步骤
1. 创建`XMLHttpRequest`对象,也就是创建一个异步调用对象.
2. 创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息.
3. 设置响应`HTTP`请求状态变化的函数.
4. 发送`HTTP`请求.
5. 获取异步调用返回的数据.
6. 使用JavaScript和DOM实现局部刷新.

```js
// code for IE7+, Firefox, Chrome, Opera, Safari
var xmlhttp = new XMLHttpRequest();

xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState == 4) {
        if(xmlhttp.status == 200){
            // do something
            console.log(xmlhttp.responseText);
        }
        else if(xmlhttp.status == 400) {
            alert('There was an error 400')
        }
        else {
            alert('something else other than 200 was returned')
        }
    }
}

xmlhttp.open("GET", "ajax_info.txt", true);
xmlhttp.send();
```

### 解释下浮动和它的工作原理？用处？浮动的问题？清除浮动的技巧
#### 工作原理
浮动元素脱离文档流。浮动元素 **碰到包含它的边框或者浮动元素的边框停留**。

#### 用处
1. 文字绕排图片的效果
2. 让原来上下堆叠的块级元素，实现布局中的分栏

#### 问题
- 父元素的高度无法被撑开，影响与父元素同级的元素
- 与浮动元素同级的非浮动元素（内联元素）会跟随其后

#### 清除浮动的三种方法
1. 为父元素添加 overflow:hidden（第一个方法很简单，缺点是不太直观.）
2. 同时浮动父元素（比较麻烦，还需 clear 父元素同级元素）
3. 添加非浮动的清除元素，使用伪类很方便，给 **父元素的最后添加一个非浮动的 子元素**，然后 clear 该子元素。

```css
.clearfix:after {
    content:".";
    display:block;
    height:0;
    visibility:hidden;
    clear:both;
}
```

### box-sizing

### HTML5 新特性
关于图像，位置，存储，多任务等功能的增加。

- 语义化更好的内容标签（header,nav,footer,aside,article,section）
- 拖拽释放(Drag and drop) API
- 音频、视频API(audio,video)
- 画布(Canvas) API
- 地理位置定位(Geolocation) API
- 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
- sessionStorage 的数据在浏览器关闭后自动删除
- 新的技术webworker, websocket

## 常见web安全及防护原理
### sql注入
就是通过把SQL命令插入到Web表单中递交，或插入到输入包含查询字符串（query string）的 url，最终达到欺骗服务器执行恶意的SQL命令。

#### 避免方式
前端需

1. 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
2. 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

### XSS
Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者插入 js 代码，然后运行，或者甚至替换你的 script 标签（联通手机流量这么干过劫持，然后你的代码就运行不了啦。。被替换成他的了，然后攻击者想干啥就干啥，只要你能干的，他都可以干）。

#### 防范
首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤

其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。

encode html tag
```
& -> &amp;
< -> &lt;
> -> &gt;
```

```js
function replaceTag(tag) {
    var tagsToReplace = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };

    return tagsToReplace[tag] || tag;
}

function safe_tags_replace(str) {
    return str.replace(/[&<>]/g, replaceTag);
}
```

### CSRF
CSRF（Cross-site request forgery），中文名称：跨站请求伪造

你这可以这么理解CSRF攻击：**攻击者盗用了你的身份，以你的名义发送恶意请求**。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

要完成一次CSRF攻击，受害者必须依次完成两个步骤：

1. 登录受信任网站A，并在本地生成Cookie。 　　
2. 在不登出A的情况下，访问危险网站B（B 网站会直接发送恶意请求，比如转钱，而这时已有Cookie，存在漏洞的 A 网站会以为这个请求是你发出的）。

#### CSRF的防御
服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。

原理就是，要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击

1. 使用验证码
2. 添加 token 并验证

### GET和POST的区别
GET：一般用于信息获取，使用URL传递少量参数（query string），对所发送信息的数量也有限制
POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

使用 post 的情况
- 向服务器发送大量数据（POST 没有数据量限制）
- 更新服务器数据操作

### 说说你对Promise的理解
依照 Promise/A+ 的定义，Promise 有四种状态：

- pending: 初始状态, 非 fulfilled 或 rejected.
- fulfilled: 成功的操作.
- rejected: 失败的操作.
- settled: Promise已被fulfilled或rejected，且不是pending

另外， fulfilled 与 rejected 一起合称 settled。

Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。

#### Promise 的构造函数
构造一个 Promise，最基本的用法如下：

```js
var promise = new Promise(function(resolve, reject) {
    if (...) {  // succeed
        resolve(result);
    } else {   // fails
        reject(Error(errMessage));
    }
});
```
Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下：

```js
promise.then(onFulfilled, onRejected)
```

接收 **两个函数** 作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。

#### promise 简单实现
> 省略了构造函数和状态

```js
var noop = function() {};

function Promise() {
    this.callbacks = [];
}

Promise.prototype = {
    constructor: Promise,

    resolve: function(result) {
        this.complete('resolve', result);
    },

    reject: function(result) {
        this.complete('reject', result);
    },

    complete: function(type, result) {
        while (this.callbacks[0]) {
            this.callbacks.shift()[type].call(this, result);
        }
    },

    then: function(successHandler, failureHandler) {
        this.callbacks.push({
            resolve: successHandler || noop,
            reject: failureHandler || noop
        });
    }
};
```

#### 我的比喻(仅用来帮助理解，面试就不要这么答了)


![](http://7xkpdt.com1.z0.glb.clouddn.com/57f886ce0b2cbfdc54ba33b6a5269dd1.png)

promise 的执行顺序到底是怎么样的呢，首先 promise 维护了一个 callbacks（本质是俩回调函数数组）。

执行这些回调函数就像放一种特殊的鞭炮一样，与普通鞭炮不同的是，每一节里面的结构比较复杂（如上图，大家可以自己补全整个鞭炮），左右有两个点，由两条线连起来，每一条线中有一个回调函数（就像鞭炮），鞭炮每爆炸一次，就相当于从一节中的左边一个点移到右边，如果你是 resolve 则是调用 then 里的 onfulfill 函数，reject 则 then 里的 onRejection 并会传递给 .catch。

所以 promise 整个执行过程分两部分，一个是构造阶段，将这个特殊的鞭炮构造出来（then，catch，可选的构造器），还有点燃阶段，resolve，reject，当点燃后，整个 promise 链就会依次执行，就像放鞭炮一样（一种特殊的鞭炮），每一节鞭炮



## 写代码
### js对象的深度克隆
```js
function clone(Obj) {   
    var buf;   
    if (Obj instanceof Array) {   
        buf = [];  //创建一个空的数组
        var i = Obj.length;   
        while (i--) {   
            buf[i] = clone(Obj[i]);   
        }   
        return buf;   
    }else if (Obj instanceof Object){   
        buf = {};  //创建一个空对象
        for (var k in Obj) {  //为这个对象添加新的属性
            buf[k] = clone(Obj[k]);   
        }   
        return buf;   
    }else{   
        return Obj;   
    }   
}  
```

### 写一个spacify函数，使得 spacify('hello world') // => 'h e l l o  w o r l d'

```js
function spacify(str) {
    return str.split('').join(' ');
}
```

### 定义log，然后它可以代理console.log的方法
希望你的侯选人可以直接使用apply,传入console的上下文也非常重要。

```js
function log(){
    console.log.apply(console, arguments);
};
```

### 每一个log消息添加一个"(app)"的前辍

```js
function log(){
    var args = Array.prototype.slice.call(arguments);
    args.unshift('(app)');

    console.log.apply(console, args);
};
```

### 上下文

```js
var User = {
    count: 1,

    getCount: function() {
        return this.count;
    }
};

console.log(User.getCount());

var func = User.getCount;
console.log(func());
```

正确的答案是1和undefined。

### 他们怎么样保证User总是能访问到func的上下文

```js
var func = User.getCount.bind(User);
console.log(func());
```

### 如何 polyfill 一个简单的 bind
```js
Function.prototype.bind = Function.prototype.bind || function(context){
    var self = this;

    return function(){
        return self.apply(context, arguments);
    };
}
```
