# 浏览器缓存介绍精简版
## 前言
这是精简版。会分两块介绍：
1. 浏览器缓存机制
2. 前端缓存优化策略

## 浏览器缓存机制
### 两个条件
当静态资源(js、css、img 等)被缓存在浏览器（默认情况下第一次访问，资源就会被缓存），浏览器再次需要请求静态资源的时候，会存在俩个if 条件判断：
1. 是否向后端发送请求
2. 是否使用缓存

正常情况下我们的理解是，先决定 是否 使用缓存，再决定是否向后端发送请求，不过浏览器的判断顺序不是这样。一图胜千言：

![](http://7xkpdt.com1.z0.glb.clouddn.com/165f046eab640ae0cda0663795a7feff.png)

### http header 介绍

![](http://7xkpdt.com1.z0.glb.clouddn.com/c93b35a563ac546f9d871be3e6c91e63.png)

如图：
1. Expires 指资源过期时间的时间点
2. Cache-Control 指缓存资源过期寿命，单位毫秒

当浏览器根据以上两个 header 发现资源已经失效，就会向后端发送请求（询问后端资源是否更改），其中 Cache-Control 强于 Expires，两者同时存在的时候过期时间只取决于 Cache-Control 的值。

1. ETag
2. Last-Modified

这俩都是用于标志 文件是否更改。


## 前端缓存优化策略
性能最好的自然是强缓存，那么当资源更新的时候怎么办，我们怎么去更新资源？？？

理论上的答案就是 对静态资源进行版本控制，加上一个 hash 用于标志文件是否更改，通过发布新的 html(html 里的引用的是否更新决定了是否更新资源)

引用方式可以通过 qurey string,如下图
![](http://7xkpdt.com1.z0.glb.clouddn.com/cb9cf161d6a68c4057e9b7a58a88689c.png)

当然实现这个的细节之处都是魔鬼，答案是使用非覆盖式发布。

（这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解它的前身今世：http://www.zhihu.com/question/20790576 ）


也可以通过修改文件名，加比如 xx.hash.js,如下图

![](http://7xkpdt.com1.z0.glb.clouddn.com/1f22ece272d39af15c4273d8b802d391.png)


总结一下就是：
大公司的静态资源优化方案，基本上要实现这么几个东西：

1. 配置超长时间的本地缓存 —— 节省带宽，提高性能
2. 版本控制 —— 精确的缓存控制
3. 静态资源 **CDN部署** —— 优化网络请求
4. 更新资源发布路径实现 **非覆盖式发布** —— 平滑升级


具体优化工具有 gulp、webpack、fis3 等，需要前后端一起配合，使得 html 对静态资源的引用能有版本控制(hash string)
